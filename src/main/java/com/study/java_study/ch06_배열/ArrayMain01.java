package com.study.java_study.ch06_배열;

public class ArrayMain01 {

    public static void main(String[] args) {
    //배열 선언 및 생성
    int[] nums = new int[100]; //크기가 5인 정수형 배열 생성.

      //  nums[1] = 20; //이러면 인덱스1에 20이 들어가겠지

        //System.out.println(nums[0]);
        //System.out.println(nums[1]);
        //System.out.println(nums[2]);
        //System.out.println(nums[3]); //원래같았으면 변수뒤에 숫자를 붙였겠지만, 대괄호로 인덱스를 참조함. 여기까지 출력시, 0,0,0,0이 나옴

        //cf) String[] names; 문자열 배열 선언방법.

        //묶어두면 좋은점. 원래 매개변수로 다음 메소드에 보내야한다?
        //매개변수로, 값을 하나씩 전달했음. 객체도 그렇게 전달했고.
        //배열은 하나로 묶어놨기떔에 하나로 보낼수도잇고 그 부분만 보낼수도 잇고 이런 장점이있음

        //더 큰 장점은, 인덱스가 잇기떔에, 반복을 돌릴수 있다는거임
        //사실 이게 배열을 쓰는 이유임. 반복이 가능하기 때문에.

        //100개 해보면.
        for(int i = 0; i < 100; i++) {
            nums[i] = (i + 1) * 10;
        }
        //그리고..

        for(int num : nums) {
            System.out.println(num);
        }

        for(int i =0; i< nums.length; i++) {
            int num = nums[i];
            System.out.println(num);

            /*공통점을 찾을수 있는가? 31번 코드랑, 35번 코드랑 똑같은 코드임.
            반복횟수, nums가 배열이고, .length를 적었음. 머냐면, 계열의 크기를 가져다줌.
            배열 쩜 렝스 하면 크기를 잡아줌
            num을 선언하고, 얘를 출력함.
            35번쓰면 뭐가좋느냐? 인덱스가 존재(i)하기 때문에, 이런게(44번코드) 가능함.
            for(int i =0; i< nums.length; i++) {
            if(i % 2 == 0) {
            continue;
            인덱스번호가 0이면 안대겟지. 1이면 출력댐. 10부터 넣어놧으니까, 20부터 줄여나옴.
            0번 index에 10이 들어감. 1번 인덱스에 20들어감.
            인덱스는 0부터 시작이고, 넣어둔 숫자는 10부터 들어갓고.
            이렇게 실행시키면은..
            20,40,60,80,100,120,140... 일케 올라감. i가 짝수면 ,출력을 안함. continue 걸었으니까.
            인덱스를 갖고놀수있게 된다. 근데 굳이 인덱스를 갖고 뭘 하는게 아니라,
            나는 이 반복을 다 뒤져야한다, 반복 ㅈㄴ돌려서 이 값들을 다 뒤져야한다 하면

            그냥 for each를 쓰면댐.
            섞어쓸건데. 거의다 for each를 쓸거임. 사실 이거 별로 쓸일없음.
            데이터 전부다옮기거나 하나를 찾거나 하는데 쓸거기때문에.
            이런식의 데이터가 있냐없냐 이런것들 맞냐 틀리냐 하는거를 찾는 행위자체를
            탐색이라고 부름

            그래서
            탐색 알고리즘이 존재함. (배열 탐색 알고리즘.)
            *선형탐색 , 2진 어쩌구... 알고리즘도 공부하면 좋아여.
            (선형은 하나하나 찾아서  느리지만, 정렬되지 않아도 사용할수 있음.
            2진은 바이너리,
            정렬된 배열에서만 사용할수 있지만 탐색속도가 선형보다 절반수준.

            시간복잡도는 선형은 n이고,
            2진은 log n임. 로그함수 그래프를 보면
            체감하듯이, 바이너리가 빠르지만, 연산이 길어질수록 느려짐)

            *해시hash
            해시는 데이터를 다루는 기술 중 하나임.
            어떤 input에 대해
            고정된 길이의 결과값을 반환하는 fx를 말함.

            이걸 해시함수라고 함. 보통 데이터의 저장 및 검색을 빠르게 하기 위해 사용됨.
            같은 입력값에 대해선, 항상 같은 해시값을 반환함.
            다른 입력값에 대해서도 같은 해시를 반환할수 있으나,
            이상적인 해시함수는 충돌의 가능성을 최소화함.
            빠른 계산을 위해 설계됨.





            ㅁㅁㅁ***ㅁ
            대충 보면, 배열이, 0번 인덱스부터 1,000번 인덱스까지 있따고 보면.
            0 1 2 ... 99. (index numbers)
            근데, 이 주소는, 메모리에 할당이 될거임. 0번 블록이 100번으로 할당됫다고 치자.
            주소는, 자료형의 바이트에 따라서 정해짐.

            그래서, 100번주소라고 하면, 다음 1번인 애는 104가 댑니다
            0,1,2,3까지가.. 103까지가, 0번 인덱스의 주소(공간의 크기)겠지

            마찬가지로 다음은 108, 112, ... 4바이트씩 늘어남.
             그니깐, 0,1,2라는 인덱스 번호로 저 주소값을 변수처럼,
             대체해 놓은것임.

             사람이, 주소를 이러케 4씩 증가해서 보는거보다 숫자로 012로 늘어나는ㄱ ㅔ낫자늠
             double썻다, 그럼 8바이트씪 늘어나겟지

             문자열을 써버렸다, 하면. 리터럴주소 참조 해가지고 ... ... 캐릭터 바이트배열을 확인해서
             또 배열 타고 들어가야댐. 크기를. 우리가 일정하게 줄수가 없어요(string같은 경우에는) capacity라고 하는데.

             01 index, 02 index ...라고 부르자, 머 이런건데. C언어에 나오는 내용(포인터라고 잇음)

             포인터 배우면 , 주소값에 의해서 실제값을 가져올수 잇게끔.
             변수를 주소값으로 바꿀수도 잇고, 그 주소를 값으로 바꿀수도 잇고, 머 그렇슴다.

             배열에 대해서 머 일케 배워여. 근데 각설하고

             원래 박스가 나눠져잇다. 이건 int인거에요. 근데 배열로 묶는순간 주소가 쭉 이어진다.
             ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ
             100 104 108 112 116 120 일케.

             즉시 참고해서 찾아갈수 잇다. 이 얘기임.근데 배열의 실제 주소는
             맨 앞의 주소0,1,2,3,... 일케 간다 이얘기임
             이게 원리

Q) 얘는 100번이고 104번이면, 같냐 == 비교하면(false나오냐?)
A)얘는 변수공간임. 0에 10넣고 1에 10넣으면, True가 나옴.
왜 트루냐, 리터럴 10이란 주소는 존재함. 요 주소를 비교하는거지, 100, 104를 비교하는게 아님.
ex) 변수 a랑 b를 만듬. a=10, b=10이면 , a==b하면 트루냐? 트루니까.

같은원리

변수의 실제 주소값을 비교하는게 아니라, 안에 들어있는 """"""""값""""""""""""을 비교함.

배열의 실제 주소값을 비교하는게 아니라, 그 안에 들어잇는.. 동어반복


*Q2)주소값을 비교했을때 달라진다? 머였는지 잘 모르겟어여.

함수에서 했는데. ch04_제어에서 조건문02.

*5번코드.
New String이랑 머 어쩌구

 변수를 만들어봅시다. String a = "김준일";
 그담에 String b = new String("김준일");
 일케 했따 보면

 a == "김준일" 의 결과값은?  멀까요 true
 b == "김준일" 의 결과값은?  멀까여? false

 시발 수업 다시해야겟네ㅋㅋㅋㅋ
 2405240246

 왜냐면

 aㅁ      ---------
 bㅁ  ㅁ  ㅣ"김준일"ㅣ
          ---------

          a변수에다가 999넣어놨어여. 그럼 a블럭에 999가 드가겟지
          b에는 뉴스트링 하는순간, "새로운 주소"로 200번을 만드는거임. 스트링. 스트링클래스 객체. 다시 그림그리면
                            200
          b------        -------
           ㅣ200 ㅣ <-   ㅣ 999 ㅣ
           ------        -------

      a의 값은 999(a==999 / 999)니까 트루고

      b블록에는 200들어잇자늠. 리터럴은 999랑 비교햇자늠. 그럼 200이랑 999랑 같지가 않으니까
      false가 나옴.

      더 자세히 설명하면 a라고 하는 변수는 주소가 따로 있음 저장소에
      그 안에 들어있는 값의 주소를 가지고 비교하는거다 이말임

      Q3) 배열로대면 어케되나여?
        담에 합시다

        240524 15:05











             */

        }






        }
/* 31을 봅시다. for each라고 하는데.
    //for, 반복하라. int num을 선언하고,
    for nums가 뭐냐, 10부터 1,000까지 들어가있는데, 0번 인덱스부터 하나씩 꺼내옴. 반복할때마다.
    그럼 밑에서 프린트ln하니까, 실행하고. 계속 넣고 실행하고 계속해서 돌아감.
    그럼, 얘는 ㅁ ㅓ가 안대냐면 인덱스로 조회가 안댐. "무조건" 첨부터 끝까지 반복함.






    */
    }


/* 대량의 변수를 어떻게 관리할 것인가?
숫자를 1~100까지 저장해야해야 하는 경우.
100개를 일일이 지정하기 귀찮잖음

그래서 배열이란걸 쓰는데. 이것도 자료형이다.
*int[] num =

자료형에서, 그냥 대괄호 열고 닫으면 됨. 인트계열인지 뭔지 쨋든

크기는 정해져있지 않음.
1.동적핟당을 해야함. 공간은 원하는 갯수만큼 만들면 댐.
ex) int[] num1 = new int[10];

대입이 되는 앞대가리는 변수임.
어떤 값의 주소를 저장하기 위한거임.
자료형은 크기를 지정하지 않음. 10이라고 적지 않는단소리

꼬리는 new int인데, 인트 배열을 만들어라, 10개 묶어서.
그럼, 인트가 4바이트니까, 4바이트 공간을 10개로 묶어둠.

인트니깐, 0000 들어가있음.

*배열엔 인덱스란 개념이 있음. 인덱스는 번호.
10개를 묶었으니까, 첫번쨰 애는 0부터 시작하겟지

0~9번까지 인덱스까지 잇겟죠

이게 주소인데.  실제론 이렇게 동작함.

//






















 */